# RuleGo 子链 (Sub-Chain) 深度闭坑指南

阿沃，子链是 RuleGo 实现复杂业务拆解、逻辑复用的核心手段。但在高并发和复杂嵌套场景下，子链调用隐藏着巨大的“天坑”。

---

## 1. 子链调用的两种方式

### 🔹 方式 A: `chain` 节点 (传统方式)
- **type**: `chain`
- **特点**: 最基础的子链调用。它将消息完整投递给目标链。
- **配置**:
    ```json
    { "ruleChainId": "sub_logic_01" }
    ```

### 🔹 方式 B: `flow` 节点 (推荐方式)
- **type**: `flow`
- **特点**: 比 `chain` 更灵活，支持**上下文继承**。
- **关键参数**:
    - `targetId`: 目标链 ID。支持变量：`${metadata.next_chain}`。
    - `extend`: (bool) **核心切入点**。
        - `true`: 子链可以访问并修改父链的 `vars`。
        - `false`: 子链拥有独立的变量空间（默认）。

---

## 2. 核心“天坑”与避坑指南

### ❌ 坑 1：无限递归死循环
- **现象**: 程序突然 CPU 飙升并在不久后因堆栈溢出或协程耗尽崩溃。
- **起因**: 链 A -> 链 B -> 链 A。RuleGo 目前并不对 DSL 层的逻辑环路做强制静态检查。
- **闭坑**: 
    1. **层级命名法**: 规定 `P_` 开头为主链，`S_` 开头为子链。子链严禁反向调用主链。
    2. **使用 `break`**: 在可能的环路点增加逻辑判断，必要时使用 `break` 节点中断。

### ❌ 坑 2：变量污染 (Shadowing)
- **现象**: 子链执行完后，主链原本的变量值发生了莫名其妙的改变。
- **起因**: 使用了 `flow` 节点且 `extend: true`。此时父子链共享同一个上下文引用。
- **闭坑**: 
    - 除非明确需要子链返回计算结果到父层变量，否则一律设为 `extend: false`。
    - 需要传递数据时，优先通过 `metadata` (元数据) 传递，元数据在传递时通常是按需拷贝或合并的。

### ❌ 坑 3：Relation 关系丢失或误判
- **现象**: 子链里执行了成功，但父链却走到了 `Failure` 分支。
- **逻辑行为**: 父链中 `chain/flow` 节点的流向取决于子链最后一个节点的输出。
- **闭坑**: 
    - 确保子链的所有分支都有明确的结尾（如 `end` 节点）。
    - 记住：子链返回给父链的关系标签，就是子链最后一个节点的 `RelationType`。

---

## 🚫 3. 架构红线：严禁“子链嵌套 Endpoint”

阿沃，这是一个毁灭性的错误：**在子链中尝试通过 HTTP Client 再次调用系统自身的另一个 Endpoint。**

- **后果**: 这会触发我们在 [Wait 机制指南](wait-mechanism.md) 里提到的“内联闭环”灾难。
- **正确做法**: 既然是在同一个进程内，直接使用 `flow` 节点调用。物理跨网段才考虑接口调用。

---

## 4. 选择标准

| 维度 | `chain` 节点 | `flow` 节点 |
|:---|:---|:---|
| **适用版本** | 全版本 | 建议 v0.20+ |
| **动态路由** | 仅限固定 ID | 支持变量 `${}` |
| **共享变量** | 不支持 | 支持 (`extend: true`) |
| **首选建议** | 遗留系统维护 | **新功能开发首选** |

阿沃，请务必保持链路的**单向性**和**简洁性**！
